// ==UserScript==
// @name         Twitter AutoHD edit fork 
// @namespace    Invertex
// @version      2.89
// @description  Forces whole image to show on timeline with bigger layout for multi-image. Forces videos/images to show in highest quality and adds a download button and right-click for content that ensures an organized filename. As well as other improvements.
// @author       Invertex
// @icon         https://i.imgur.com/M9oO8K9.png
// @match        https://*.twitter.com/*
// @match        https://*.twimg.com/media/*
// @match        https://*.x.com/*
// @match        https://*.fixupx.com/*
// @match        https://*.vxtwitter.com/*
// @match        https://*.fxtwitter.com/*
// @noframes
// @grant        GM_xmlhttpRequest
// @grant        GM_download
// @grant        GM_openInTab
// @grant        GM_setClipboard
// @grant        unsafeWindow
// @grant        GM_setValue
// @grant        GM_getValue
// @run-at       document-start
// @require      https://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js
// ==/UserScript==

const cooky = getCookie("ct0");
const modifiedAttr = "THD_modified";
const GM_OpenInTabMissing = typeof GM_openInTab === 'undefined';

const tweets = new Map();

const argsChildAndSub = { attributes: false, childList: true, subtree: true };
const argsChildOnly = { attributes: false, childList: true, subtree: false };
const argsChildAndAttr = { attributes: true, childList: true, subtree: false };
const argsAll = { attributes: true, childList: true, subtree: true };
const argsAttrOnly = { attributes: true, childList: false, subtree: false };

const dlSVG = `
<g>
  <path d="M 8 51 C 5 54 5 48 5 42 L 5 -40 C 5 -45 -5 -45 -5 -40 V 42 C -5 48 -5 54 -8 51 L -48 15 C -51 12 -61 17 -56 22 L -12 61 C 0 71 0 71 12 61 L 56 22 C 61 17 52 11 48 15 Z"></path>
  <path d="M 56 -58 C 62 -58 62 -68 56 -68 H -56 C -62 -68 -62 -58 -56 -58 Z"></path>
</g>`;

const twitSVG = `
<g>
  <path d="M23.643 4.937c-.835.37-1.732.62-2.675.733.962-.576 1.7-1.49 2.048-2.578-.9.534-1.897.922-2.958 1.13-.85-.904-2.06-1.47-3.4-1.47-2.572 0-4.658 2.086-4.658 4.66 0 .364.042.718.12 1.06-3.873-.195-7.304-2.05-9.602-4.868-.4.69-.63 1.49-.63 2.342 0 1.616.823 3.043 2.072 3.878-.764-.025-1.482-.234-2.11-.583v.06c0 2.257 1.605 4.14 3.737 4.568-.392.106-.803.162-1.227.162-.3 0-.593-.028-.877-.082.593 1.85 2.313 3.198 4.352 3.234-1.595 1.25-3.604 1.995-5.786 1.995-.376 0-.747-.022-1.112-.065 2.062 1.323 4.51 2.093 7.14 2.093 8.57 0 13.255-7.098 13.255-13.254 0-.2-.005-.402-.014-.602.91-.658 1.7-1.477 2.323-2.41z"></path>
</g>`;

const bookmarkSVG = `
<g>
  <path d="M17 3V0h2v3h3v2h-3v3h-2V5h-3V3h3zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V11h2v11.94l-8-5.71-8 5.71V4.5C4 3.12 5.119 2 6.5 2h4.502v2H6.5z"></path>
</g>`;

const unbookmarkSVG = `
<g>
  <path d="M16.586 4l-2.043-2.04L15.957.54 18 2.59 20.043.54l1.414 1.42L19.414 4l2.043 2.04-1.414 1.42L18 5.41l-2.043 2.05-1.414-1.42L16.586 4zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V11h2v11.94l-8-5.71-8 5.71V4.5C4 3.12 5.119 2 6.5 2h4.502v2H6.5z"></path>
</g>`;


addGlobalStyle(`
@-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } }
div#thd_button_Download[downloading], div#thd_button_Download[downloading] svg { pointer-events: none !important; }
div#thd_button_Download[downloading] svg { background-color: rgba(143, 44, 242, 0.5); border-radius: 12px; animation: spin 2s linear infinite; }
div#thd_button_Download[downloading] svg > path { fill: rgba(255,255,255,0.2); }
div[thd_customctx]:has(video[downloading]) { border: 3px solid cyan; border-radius: 0 12px 12px 0; animation: dl-animation 2s infinite; }
@keyframes dl-animation { 0%, 100% { border-color: cyan; background-color: cyan; } 33% { border-color: magenta; background-color: magenta; } 66% { border-color: yellow; background-color: yellow; } }
.loader { border: 16px solid #f3f3f373; margin: auto; border-top: 16px solid #3498db99; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
.context-menu { position: absolute; margin: 0; background: #040404; border: 1px solid #0e0e0e; border-radius: 5px; }
.context-menu ul, .context-menu ul li { margin: 0; padding: 0; list-style: none; }
.context-menu ul { min-width: 190px; }
.context-menu ul li { padding: 7px 0; border: 1px solid #0e0e0e; color: #c1bcbc; font-family: sans-serif; user-select: none; }
.context-menu ul li:hover { background: #202020; }
a[aria-label="Grok"], div > aside[aria-label*="Premium"], div[data-testid="inlinePrompt"]:has(div > a[href^="/i/premium_sign_up"]), div:has(> div > div[data-testid="bookmark"], > div > div[data-testid="removeBookmark"]) > div#thd_button_Bookmark { display: none !important; }
.thd_settings_collapsible { background-color: rgb(28, 30, 34); color: rgb(180, 183, 173); cursor: pointer; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; border-radius: 11px 11px 0 0; padding: 8px 14px; }
.thd_settings_collapsible:after { content: "Show \u2795"; font-size: 13px; float: right; margin-left: 5px; }
.thd_settings_active, .thd_settings_collapsible:hover { background-color: rgb(38, 40, 44); }
.thd_settings_active:after { content: "Hide \u2796"; }
.thd_settings_content { display: flex; flex-direction: column; background-color: rgb(22, 24, 28); padding-bottom: 6px; }
.thd_settings_content_closed { display: none !important; }
.thd_settings_toggle { margin: 0.01em 0.4em; border: 0.015em solid #101010; background-color: #202020; border-radius: 6px; color: rgb(100, 100, 100); }
.thd_settings_toggle:hover { background-color: #393838; border: 0.045em solid #505050; cursor: pointer; color: rgb(210, 210, 210); }
.thd_settings_toggle_enabled { background-color: #292828; border: 0.045em solid #404040; cursor: pointer; color: rgb(190, 190, 190); }
`);
// Greasemonkey specific functionality check
const isGM = (typeof GM_addValueChangeListener === 'undefined');

// StringBuilder class for efficient string manipulation
function StringBuilder(value) {
    this.strings = [];
    if (value) this.append(value);
}

StringBuilder.prototype.append = function(value) {
    if (value) this.strings.push(value);
};

StringBuilder.prototype.clear = function() {
    this.strings.length = 0;
};

StringBuilder.prototype.toString = function() {
    return this.strings.join("");
};

const sb = new StringBuilder("");

// Function to filter M3U8 video sources for the best quality
const filterVideoSources = function(m3u8) {
    const regexResolution = /(?<=,RESOLUTION=)(.*)(?=x)/gm;
    const regexAudio = /(?<=GROUP-ID="audio-)(.*)(?=",)/gm;

    let bestLine = 0;
    let bestAudioLine = 0;
    let bestResolution = 0;
    let bestAudioBandwidth = 0;
    let avc1FallbackVideo = 0;

    sb.clear();

    let lines = m3u8.split('#');
    sb.append(lines[0]);

    for (let i = 1; i < lines.length; i++) {
        let line = lines[i];

        if (line.includes('STREAM-INF:')) {
            let resolutionMatch = line.match(regexResolution);
            let resolution = resolutionMatch ? parseInt(resolutionMatch[0]) : 0;
            if (resolution > bestResolution) {
                bestResolution = resolution;
                bestLine = i;
            } else if (bestLine === 0) {
                bestLine = i;
            }
            if (line.includes('/avc1/')) {
                avc1FallbackVideo = i;
            }
        } else if (line.includes('EXT-X-MEDIA:NAME="Audio"')) {
            let bandwidthMatch = line.match(regexAudio);
            let bandwidth = bandwidthMatch ? parseInt(bandwidthMatch[0]) : 0;
            if (bandwidth > bestAudioBandwidth) {
                bestAudioBandwidth = bandwidth;
                bestAudioLine = i;
            } else if (bestAudioLine === 0) {
                bestAudioLine = i;
            }
        } else {
            sb.append('#' + lines[i]);
        }
    }

    let doAVC1Fallback = bestLine > 0 && !lines[bestLine].includes('/avc1/') && avc1FallbackVideo > 0;

    if (bestAudioLine > 0) {
        sb.append('#' + lines[bestAudioLine]);
        if (doAVC1Fallback) {
            let avcLine = lines[avc1FallbackVideo];
            let audioGroup = avcLine.match(/AUDIO="([^"]+)"/);
            if (audioGroup) {
                audioGroup = audioGroup[1];
                for (let i = 1; i < lines.length; i++) {
                    let line = lines[i];
                    if (line.includes('TYPE=AUDIO') && line.includes(audioGroup)) {
                        sb.append('#' + line);
                        break;
                    }
                }
            }
        }
    }

    if (bestLine > 0) {
        sb.append('#' + lines[bestLine]);
        if (doAVC1Fallback) {
            sb.append('#' + lines[avc1FallbackVideo]);
        }
    }

    return sb.toString();
};

// Function to convert X domain URLs to Twitter domain URLs
const changeToTwitter = function(url) {
    return url.replace('/x.com/', '/twitter.com/').replace('.x.com/', '.twitter.com/');
};


// Store transaction ID and authorization headers
var transactID = "";
var authy = "";

// Intercept and store request headers
var oldReqHead = unsafeWindow.XMLHttpRequest.prototype.setRequestHeader;
unsafeWindow.XMLHttpRequest.prototype.setRequestHeader = exportFunction(function(name, value) {
    if (name === "X-Client-Transaction-Id") {
        transactID = value;
    } else if (name === "authorization") {
        authy = value;
    }
    oldReqHead.call(this, name, value);
}, unsafeWindow);

// Intercept XMLHttpRequests to process and modify responses
var openOpen = unsafeWindow.XMLHttpRequest.prototype.open;
unsafeWindow.XMLHttpRequest.prototype.open = exportFunction(function(method, url) {
    // Optionally modify URL here
    // url = changeToTwitter(url);
    processXMLOpen(this, method, url);
    openOpen.call(this, method, url);
}, unsafeWindow);

// Process and modify XMLHttpRequests based on URL
function processXMLOpen(thisRef, method, url) {
    if (prefsLoaded === false) {
        loadToggleValues();
    }

    // Handle M3U8 video streams
    if (url.includes('video.twimg.com') || url.includes('master_dynamic') && url.includes('.m3u8?')) {
        thisRef.addEventListener('readystatechange', function(e) {
            if (toggleHQVideo.enabled && thisRef.readyState === 4) {
                const m3uText = e.target.responseText;
                if (!m3uText.includes('#EXT-X-MEDIA-SEQUENCE')) {
                    const m3u = filterVideoSources(m3uText);
                    Object.defineProperty(thisRef, 'response', { writable: true });
                    Object.defineProperty(thisRef, 'responseText', { writable: true });
                    thisRef.response = thisRef.responseText = m3u;
                }
            }
        });
    }
    // Handle show.json requests
    else if (url.includes('show.json?')) {
        thisRef.addEventListener('readystatechange', function(e) {
            if (toggleHQVideo.enabled && thisRef.readyState === 4) {
                try {
                    let json = JSON.parse(e.target.response);
                    let vidInfo = json.extended_entities?.media?.video_info ?? null;

                    if (vidInfo && vidInfo.variants && vidInfo.variants.length > 2) {
                        vidInfo.variants = stripVariants(vidInfo.variants, true);
                        Object.defineProperty(thisRef, 'response', { writable: true });
                        Object.defineProperty(thisRef, 'responseText', { writable: true });
                        thisRef.response = thisRef.responseText = JSON.stringify(json);
                    }
                } catch (error) {
                    console.error('Error processing show.json response:', error);
                }
            }
        });
    }
    // Modify GraphQL requests
    else if (url.includes("/graphql/")) {
        url = url.replace('includePromotedContent%22%3Atrue', 'includePromotedContent%22%3Afalse')
                 .replace('phone_label_enabled%22%3Afalse', 'phone_label_enabled%22%3Atrue')
                 .replace('reach_fetch_enabled%22%3Atrue', 'reach_fetch_enabled%22%3Afalse')
                 .replace('withQuickPromoteEligibilityTweetFields%22%3Atrue', 'withQuickPromoteEligibilityTweetFields%22%3Afalse')
                 .replace('article_tweet_consumption_enabled%22%3Atrue', 'article_tweet_consumption_enabled%22%3Afalse')
                 .replace('count%22%3A20', 'count%22%3A30');

        thisRef.addEventListener('readystatechange', function(req) {
            if (thisRef.readyState === 4) {
                let json = null;
                try {
                    json = JSON.parse(req.target.response);
                } catch (e) {
                    if (req.target.status >= 400 && url.includes('TweetDetail?')) {
                        window.location.href = window.location.href; // Refresh on error
                    }
                    return;
                }

                if (json?.data) {
                    processTimelineData(json);
                    Object.defineProperty(thisRef, 'response', { writable: true });
                    Object.defineProperty(thisRef, 'responseText', { writable: true });
                    thisRef.response = thisRef.responseText = JSON.stringify(json);
                }
            }
        });
    }
    // Handle videoads requests
    else if (url.includes('/videoads/')) {
        thisRef.addEventListener('readystatechange', function(e) {
            if (thisRef.readyState === 4) {
                Object.defineProperty(thisRef, 'responseText', { writable: true });
                thisRef.responseText = "{}";
            }
        });
    }
    // Handle notifications
    else if (url.includes('all.json?') && window.location.href.endsWith('/notifications')) {
        thisRef.addEventListener('readystatechange', function(e) {
            if (thisRef.readyState === 4) {
                try {
                    let json = JSON.parse(e.target.response);
                    let notifs = json?.timeline?.instructions ?? null;
                    if (notifs) {
                        notifs = processNotificationsData(notifs);
                        Object.defineProperty(thisRef, 'response', { writable: true });
                        Object.defineProperty(thisRef, 'responseText', { writable: true });
                        thisRef.response = thisRef.responseText = JSON.stringify(json);
                    }
                } catch (error) {
                    console.error('Error processing notifications response:', error);
                }
            }
        });
    }
    // Uncomment and adjust if needed
    /* else if (url.includes('guide.json')) { // Explore
        this.addEventListener('readystatechange', function (e) {
            if (this.readyState === 4) {
                let json = JSON.parse(e.target.response);
                processExploreData(json?.globalObjects?.tweets);
                Object.defineProperty(this, 'responseText', { writable: true });
                this.responseText = JSON.stringify(json);
            }
        });
    } */
}


// Function to filter media variants and keep the highest quality
function stripVariants(variants, keepM3U = false) {
    if (!variants) return null;

    // Find the best quality variant based on bitrate
    let bestQuality = variants.reduce((a, b) => (a?.bitrate ?? 0) > (b?.bitrate ?? 0) ? a : b);

    if (keepM3U) {
        // Find the M3U8 variant if needed
        let m3u = variants.find(entry => entry.url.includes('.m3u8'));
        return m3u ? [bestQuality, m3u] : [bestQuality];
    }

    return bestQuality;
}

// Process media data based on user preferences
function processMediaResponseData(mediasJson) {
    let hqVideo = toggleHQVideo.enabled;
    let hqImg = toggleHQImg.enabled;

    mediasJson.forEach(mediaItem => {
        if (hqVideo && mediaItem.type === 'video') {
            mediaItem.video_info.variants = stripVariants(mediaItem.video_info.variants, true);
        } else if (hqImg && mediaItem.type === 'photo') {
            mediaItem.media_url_https = getHighQualityImage(mediaItem.media_url_https);
        }
    });
}

// Tweet class to manage tweet data and media
class Tweet {
    constructor(tweetResult) {
        let data = tweetResult;
        if (data?.tweet) data = data.tweet; // Handle limited tweets

        this.isRetweet = Boolean(data?.legacy?.retweeted_status_result?.result);
        if (this.isRetweet) {
            data = data.legacy.retweeted_status_result.result;
            if (data?.tweet) data = data.tweet;
        }

        this.id = data?.rest_id ?? data?.conversation_id;
        tweets.set(this.id, this);

        let legacy = data?.legacy ?? data; // Handle edge cases

        this.media = legacy?.extended_entities?.media;
        this.hasMedia = Boolean(this.media);

        this.quote = data?.quoted_status_result?.result;
        this.isQuote = Boolean(this.quote);
        if (this.isQuote) this.quote = new Tweet(this.quote);
        this.quoteHasMedia = this.isQuote && this.quote.hasMedia;

        this.username = data?.core?.user_results?.result.legacy?.screen_name;
        this.url = `https://twitter.com/${this.username}/${this.id}`;

        if (this.hasMedia) {
            processMediaResponseData(this.media);
            if (this.isQuote && this.quoteHasMedia) {
                processMediaResponseData(this.quote.media);
            }
        } else if (data?.card?.legacy) {
            this.handleCard(data.card.legacy);
        }

        if (data?.edit_control?.edit_tweet_ids) {
            data.edit_control.edit_tweet_ids.forEach(edit_id => tweets.set(edit_id, this));
        }

        this.isBookmarked = Boolean(legacy?.bookmarked);
    }

    // Handle card media and information
    handleCard(cardLegacy) {
        if (cardLegacy.binding_values) {
            for (let bv of cardLegacy.binding_values) {
                if (bv.key === "unified_card") {
                    let cardValue = bv.value;
                    if (cardValue?.type !== "STRING") break;

                    let valueJson = JSON.parse(cardValue.string_value);
                    valueJson.type = "video"; // Prevent video from opening in a new tab

                    if (valueJson.components.length > 0) {
                        this.media = [];
                        let hqVideo = toggleHQVideo.enabled;
                        valueJson.components.forEach(comp => {
                            if (comp.startsWith("media_")) {
                                let compData = valueJson.component_objects[comp].data;
                                let mediaId = compData.id;
                                let destination = valueJson.destination_objects[compData.destination].data.url_data;
                                destination.vanity = destination.url.substr(0, 40);
                                let mediaData = valueJson.media_entities[mediaId];
                                if (hqVideo && mediaData.video_info) {
                                    mediaData.video_info.variants = stripVariants(mediaData.video_info.variants, true);
                                }
                                this.media.push(mediaData);
                            }
                            if (comp.startsWith("details_")) {
                                let compData = valueJson.component_objects[comp].data;
                                let destination = valueJson.destination_objects[compData.destination].data.url_data;
                                destination.vanity = destination.url.substr(0, 90);
                            }
                        });

                        this.hasMedia = this.media.length > 0;
                        cardValue.string_value = JSON.stringify(valueJson);
                    }
                } else if (bv.key === "photo_image_full_size_original") {
                    let card_img = bv.value?.image_value;
                    if (card_img) {
                        let card_img_id = card_img.url.split('?')[0].split('/').at(-1);
                        this.media = [{
                            type: "photo",
                            media_url_https: card_img.url,
                            id_str: card_img_id,
                            expanded_url: this.url,
                            original_info: { width: card_img.width, height: card_img.height }
                        }];
                        this.hasMedia = true;
                        break;
                    }
                }
            }
        }
    }

    get bookmarked() { return this.isBookmarked; }
    bookmark() { this.isBookmarked = true; }
    unbookmark() { this.isBookmarked = false; }

    getMediaData(index) {
        if (!this.media || this.media.length <= index) return null;

        let mediaItem = this.media[index];
        let username = this.username;
        let id = this.id;
        let media_id = mediaItem.id_str;
        let media_url = mediaItem.media_url_https;
        let url = mediaItem.expanded_url;
        if (!url.includes('card_img/')) {
            let comIndex = url.indexOf('.com/');
            let urlParts = url.substring(comIndex < 0 ? 0 : comIndex + 5).split('/');
            if (urlParts.length > 3) {
                username = urlParts[0];
                id = urlParts[2];
            }
        }

        let isVideo = mediaItem.type === 'video' || media_url.includes('/tweet_video_thumb/');
        let isPhoto = mediaItem.type === 'photo';
        let counter = this.media.length < 2 ? -1 : index + 1;

        return {
            username,
            id,
            media_id,
            media_url,
            mediaNum: counter,
            isVideo,
            isPhoto,
            getContentURL: () => {
                if (isVideo) {
                    return stripVariants(mediaItem.video_info.variants).url;
                }
                return getHighQualityImage(media_url);
            },
            type: mediaItem.type,
            width: mediaItem.original_info.width,
            height: mediaItem.original_info.height
        };
    }
}


// Process notifications data, filtering out unwanted entries
function processNotificationsData(notifs) {
    if (notifs.length > 0) {
        for (let i = notifs.length - 1; i >= 0; i--) {
            if ('addEntries' in notifs[i]) {
                let entries = notifs[i].addEntries?.entries ?? [];
                for (let e = entries.length - 1; e >= 0; e--) {
                    let entry = entries[e];
                    if (entry?.content?.item?.clientEventInfo?.element?.startsWith("generic_magic")) {
                        entries.splice(e, 1);
                    }
                }
            }
        }
    }
}

// Process explore tweets and create Tweet instances
function processExploreData(exploreTweets) {
    exploreTweets.forEach(tweetData => new Tweet(tweetData));
}

// Process a single timeline item
function processTimelineItem(item) {
    if (item?.promotedMetadata) return false; // Skip promoted items

    let result = item?.tweet_results?.result;
    if (result) new Tweet(result);

    return true;
}

// Process a single timeline entry
function processTimelineEntry(entry) {
    if (entry?.content?.clientEventInfo?.component === "suggest_promoted") {
        entry.content = {}; // Remove suggested promoted content
        return;
    }

    let items = entry?.content?.items;
    if (items) {
        for (let i = items.length - 1; i >= 0; i--) {
            if (!processTimelineItem(items[i].item.itemContent)) {
                items.splice(i, 1);
            }
        }
    } else if (entry?.content?.itemContent) {
        if (!processTimelineItem(entry.content.itemContent)) {
            entry.content = {}; // Remove content if not processed
        }
    } else if (entry?.item?.itemContent) {
        if (!processTimelineItem(entry.item.itemContent)) {
            entry.item = {}; // Remove item if not processed
        }
    }
}

// Process multiple timeline entries
function processTimelineEntries(entries) {
    entries.forEach(entry => processTimelineEntry(entry));
}

// Process multiple timeline module entries
function processTimelineModuleEntries(moduleEntries) {
    moduleEntries.forEach(entry => processTimelineEntry(entry));
}

// Process timeline data from various sources
function processTimelineData(json) {
    let instructions = json?.data?.home?.home_timeline_urt?.instructions
        || json.data?.user?.result?.timeline_v2?.timeline?.instructions
        || json.data?.user?.result?.timeline?.timeline?.instructions
        || json.data?.threaded_conversation_with_injections_v2?.instructions
        || json.data?.bookmark_timeline_v2?.timeline?.instructions
        || json.data?.list?.tweets_timeline?.timeline?.instructions
        || json.data?.search_by_raw_query?.search_timeline?.timeline?.instructions
        || json.data?.communityResults?.result?.ranked_community_timeline?.timeline?.instructions;

    if (!instructions) return;

    instructions.forEach(instruction => {
        switch (instruction.type) {
            case "TimelineAddEntries":
                processTimelineEntries(instruction.entries);
                break;
            case "TimelinePinEntry":
                processTimelineEntry(instruction.entry); // Process pinned tweet
                break;
            case "TimelineAddToModule":
                processTimelineModuleEntries(instruction.moduleItems); // Process module entries
                break;
        }
    });
}

let firstRun = true;

// Process tweet queries with various filters
function processTweetsQuery(entries) {
    for (let i = entries.length - 1; i >= 0; i--) {
        let entry = entries[i];
        let content = entry.content;
        if (!content) continue;

        if (content.items) {
            content = content.items[0].item.itemContent;
        } else {
            content = content.itemContent;
        }

        if (!content || !content.tweet_results) continue;
        if (firstRun && entries.length <= 4) continue; // Avoid freezing on few initial entries

        if (content.promotedMetadata?.advertiser_results) {
            entries.splice(i, 1); // Remove promoted tweets
        } else if (content.socialContext) {
            let contextType = content.socialContext.contextType;
            if ((!toggleLiked.enabled && contextType === "Like")
                || (!toggleFollowed.enabled && contextType === "Follow")
                || (!toggleTopics.enabled && content.socialContext.type === "TimelineTopicContext")) {
                entries.splice(i, 1);
            }
        } else if (!toggleRetweet.enabled
            && content.tweet_results.result.legacy?.retweeted_status_result?.result?.core?.user_results?.result.legacy.following === false) {
            entries.splice(i, 1); // Hide non-user retweets
        }
    }

    firstRun = false;
    return entries;
}

function getPostButtonCopy(tweet, name, svg, svgViewBox, color, bgColor, onHovering, onNotHovering) {
    let getButtonToDupe = function (btnGrp) {
        let lastChd = btnGrp.lastChild;
        let newNode = lastChd.cloneNode(true);
        lastChd.className = btnGrp.childNodes.item(2).className;
        return { btn: newNode, origBtn: lastChd };
    };

    let isIframe = false;
    let id = `thd_button_${name}`;

    let buttonGrp = tweet.closest('article[role="article"]')?.querySelector('div[role="group"][id^="id__"]');
    if (!buttonGrp) {
        buttonGrp = tweet.querySelector('div a[href*="like?"]')?.parentElement;
        if (buttonGrp) {
            isIframe = true;
            getButtonToDupe = function (btnGrp) {
                let orig = btnGrp.querySelector('a:nth-child(2)');
                return { btn: orig.cloneNode(true), origBtn: orig };
            };
        }
    }

    if (!buttonGrp || buttonGrp.querySelector(`#${id}`)) return null; // Button already exists

    buttonGrp.style.maxWidth = "100%";

    let btnDupe = getButtonToDupe(buttonGrp);

    if (btnDupe.btn) {
        let btn = btnDupe.btn;
        buttonGrp.insertBefore(btn, btnDupe.origBtn);

        btn.id = id;
        btn.style.margin = "0 8px";
        $(btn.parentNode).addClass(btn.className);
        btn.setAttribute('aria-label', name);
        btn.title = name;

        const iconDiv = isIframe ? btn.querySelector('div[dir="auto"]') : btn.querySelector('div[dir="ltr"]');
        const svgElem = btn.querySelector('svg');
        const bg = isIframe ? svgElem.parentElement : iconDiv.firstElementChild.firstElementChild;

        svgElem.innerHTML = svg;
        svgElem.setAttribute('viewBox', svgViewBox);

        const oldBGColor = $(bg).css("background-color");
        const oldIconColor = $(iconDiv).css("color");

        let hover = function() {
            $(bg).css("background-color", bgColor).css("border-radius", "20px");
            $(svgElem).css("color", color);
        };

        let unhover = function() {
            $(bg).css("background-color", oldBGColor);
            $(svgElem).css("color", oldIconColor);
            if (onNotHovering) onNotHovering(svgElem);
        };

        let updateColor = function() {
            if (btn.matches(":hover")) unhover();
            else hover();
        };

        $(btn).hover(hover, unhover);

        $(bg).css("background-color", oldBGColor);
        $(svgElem).css("color", oldIconColor);

        return { btn, origBtn: btnDupe.origBtn, inIframe: isIframe, svg: svgElem, doHover: hover, doUnhover: unhover, updateCol: updateColor };
    }

    return null;
}

function addBookmarkButton(tweetElem, tweetData) {
    if (!tweetElem || !tweetData) return;

    let id = tweetData.id;
    let existingBookmark = tweetElem.querySelector('div[data-testid="bookmark"]');

    if (existingBookmark) {
        existingBookmark = existingBookmark.parentElement;
        existingBookmark.style.flex = "0.6 1.0";
        let otherBtn = existingBookmark.closest('[role="group"]').childNodes.item(2);
        $(existingBookmark).removeClass().addClass(otherBtn.className);
        return;
    }

    let onHoverStopped = function(svgElem, tweetID) {
        let tweetData = tweets.get(tweetID);
        if (tweetData && tweetData.bookmarked) {
            $(svgElem).css("color", "#1c9bf0FF");
        }
    };

    const btnCopy = getPostButtonCopy(tweetElem, "Bookmark", bookmarkSVG, "0 0 24 24", "#1c9bf0", "#1c9bf01a", () => {}, (svgElem) => onHoverStopped(svgElem, id));

    if (!btnCopy || !btnCopy.btn) return;

    let btn = btnCopy.btn;
    onHoverStopped(btnCopy.svg, id);

    $(btn).click(function (e) {
        e.preventDefault();
        e.stopPropagation();

        let tweetData = tweets.get(id);
        if (!tweetData) return;

        if (tweetData.bookmarked) {
            unbookmarkPost(id, (resp) => {
                if (resp.status < 300) {
                    tweetData.unbookmark();
                    btnCopy.updateCol();
                }
            });
        } else {
            bookmarkPost(id, (resp) => {
                if (resp.status < 300) {
                    tweetData.bookmark();
                    btnCopy.updateCol();
                }
            });
        }
    });

    btnCopy.btn.style.flex = "0.6 1.0";
}

async function addDownloadButton(tweetElem, tweetData, mediaInfo) {
    if (mediaInfo.data.mediaNum <= 1 || tweetData.media.some(media => media.isVideo)) return;

    const btnCopy = getPostButtonCopy(tweetElem, "Download", dlSVG, "-80 -80 160 160", "#f3d607FF", "#f3d60720");
    if (!btnCopy || !btnCopy.btn) return;

    const dlBtn = btnCopy.btn;
    const isIframe = btnCopy.inIframe;
    const filename = filenameFromMediaData(mediaInfo.data);
    const linkElem = isIframe
        ? $(dlBtn).wrapAll(`<a href="${mediaInfo.data.getContentURL()}" download="${filename}"></a>`)[0].parentElement
        : dlBtn;

    if (isIframe) {
        dlBtn.className = "";
        linkElem.setAttribute('download', filename);
        dlBtn.querySelector('div[dir="auto"] > span').innerText = "Download";
        btnCopy.btn = $(linkElem).wrapAll(`<div class="${dlBtn.className}"></div>`)[0].parentElement;
    } else {
        dlBtn.style.margin = "";
        linkElem.style.cssText = dlBtn.style.cssText;
    }

    $(linkElem).click(async function (e) {
        e.preventDefault();
        e.stopPropagation();
        linkElem.setAttribute('downloading', '');
        await download(mediaInfo.data.getContentURL(), filename);
        linkElem.removeAttribute('downloading');
    });

    btnCopy.btn.className = btnCopy.origBtn.className;
    btnCopy.btn.style.flex = "0.6 1.0";
    btnCopy.btn.style.justifyContent = "center !important";
}
function waitForImgLoad(img) {
    return new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = reject;
    });
}

function updateImgSrc(imgElem, bgElem, src) {
    if (imgElem.src !== src && toggleHQImg.enabled) {
        imgElem.src = src;
        bgElem.style.backgroundImage = `url("${src}")`;
    }
}

function updateElemPadding(panelCnt, background, imgContainerElem) {
    if (panelCnt !== 3) {
        if (background) {
            background.style.backgroundSize = "cover";
        }
    }
    if (panelCnt < 2) {
        // imgContainerElem.removeAttribute('style');
    } else {
        imgContainerElem.style.marginLeft = "0%";
        imgContainerElem.style.marginRight = "0%";
        imgContainerElem.style.marginTop = "0%";
    }
}

function updateContentElement(tweetElem, tweetData, mediaInfo, elemIndex, elemCnt) {
    let mediaElem = mediaInfo.mediaElem;
    let tweetPhoto = mediaElem.closest('div[data-testid="tweetPhoto"],div[data-testid^="card.wrapper"]');
    const flexDir = $(tweetPhoto).css('flex-direction');
    const isVideo = mediaInfo.data.isVideo;
    let bg = isVideo ? mediaElem.parentElement : tweetPhoto.querySelector('div[style^="background-image"]');

    let linkElem = tweetPhoto.querySelector('div[data-testid="videoPlayer"]') ?? mediaElem?.closest('a');

    mediaInfo.tweetPhotoElem = tweetPhoto;
    mediaInfo.linkElem = linkElem;
    mediaInfo.bgElem = bg;
    mediaInfo.flex = flexDir;

    if (isVideo) {
        addDownloadButton(tweetElem, tweetData, mediaInfo);
        if (mediaInfo.data.media_url.includes('/tweet_video_thumb')) {
            mediaElem.setAttribute('controls', "true");
            mediaElem.onplaying = () => {
                if (!mediaElem.paused && !mediaElem.getAttribute("isHovering")) {
                    mediaElem.removeAttribute('controls');
                }
            };
            mediaElem.onmouseover = () => {
                mediaElem.controls = true;
                mediaElem.setAttribute("isHovering", true);
            };
            mediaElem.onmouseout = () => {
                if (!mediaElem.paused) {
                    mediaElem.removeAttribute('controls');
                    mediaElem.removeAttribute("isHovering");
                }
            };

            let vidComp = mediaElem.closest('div[data-testid="videoComponent"]');
            if (vidComp && vidComp.childElementCount > 1) {
                let tab = vidComp.lastElementChild;
                if (tab) {
                    tab.remove();
                }
            }
        }
    } else if (toggleHQImg.enabled) {
        let hqImg = mediaInfo.data.getContentURL();
        updateImgSrc(mediaElem, bg, hqImg);
    }

    addCustomCtxMenu(tweetData, mediaInfo, mediaInfo.linkElem);
    updateElemPadding(elemCnt, bg, tweetPhoto);
    doOnAttributeChange(tweetPhoto, (container) => updateElemPadding(elemCnt, bg, container), true);
}

function updateContentElements(tweetElem, tweetData, mediaInfos) {
    if (!tweetData || !mediaInfos) return;

    let elemCnt = mediaInfos.length;
    for (let i = 0; i < elemCnt; i++) {
        updateContentElement(tweetElem, tweetData, mediaInfos[i], i, elemCnt);
    }

    updateContentLayout(tweetElem, tweetData, mediaInfos);
}

async function updatePadder(tweetElem, ratio) {
    let padder = await awaitElem(tweetElem, 'div[id^="id_"] [thd_customctx]');
    if (!padder) return;

    padder = padder.closest('div[id^="id_"]').querySelector('div[style^="padding-bottom"]');
    const modPaddingAttr = "modifiedPadding";

    if (padder && !addHasAttribute(padder, modPaddingAttr)) {
        const padderParent = padder.parentElement;
        const flexer = padder.closest('div[id^="id_"] > div');
        const bg = flexer.querySelector('div[style^="background"] > div');

        padder.style.paddingBottom = `${ratio}%`;
        flexer.style.alignSelf = "normal !important";
        if (bg) bg.style.width = "100%";

        padderParent.removeAttribute('style');

        doOnAttributeChange(padder, (padderElem) => {
            if (!padderElem.getAttribute("modifiedPadding")) {
                padderElem.style.paddingBottom = `${ratio}%`;
            }
        });
        if (!addHasAttribute(padderParent, modPaddingAttr)) {
            doOnAttributeChange(padderParent, (padderParentElem) => {
                if (!padderParentElem.getAttribute("modifiedPadding")) {
                    padderParentElem.removeAttribute('style');
                }
            });
        }
    }
}

function updateContentLayout(tweetElem, tweetData, mediaElems) {
    processBlurButton(tweetElem);

    let elemCnt = mediaElems.length;
    let ratio = (mediaElems[0].data.height / mediaElems[0].data.width);

    if (elemCnt < 2 && mediaElems[0].data.isVideo) {
        let innerHeight = window.innerHeight;
        let curRatio = (innerHeight / curLayoutWidth) * 0.8;
        if (curRatio < ratio) ratio = curRatio;
    }
    ratio *= 100;
    if (elemCnt === 2) {
        let img1 = mediaElems[0];
        let img2 = mediaElems[1];
        let img1Ratio = img1.data.height / img1.data.width;
        let img2Ratio = img2.data.height / img2.data.width;
        let imgToRatio = img1Ratio > img2Ratio ? img1 : img2;
        ratio = (imgToRatio.data.height / imgToRatio.data.width);

        img1.bgElem.style.backgroundSize = "cover";
        img2.bgElem.style.backgroundSize = "cover";
        img1.tweetPhotoElem.parentElement.removeAttribute("style");
        img2.tweetPhotoElem.parentElement.removeAttribute("style");

        if (img1.flex === "row") {
            if (imgToRatio.data.height > imgToRatio.data.width) {
                ratio *= 0.5;
            }
        } else {
            ratio *= 0.5;
        }

        if (imgToRatio.data.isVideo && imgToRatio.data.width > imgToRatio.data.height) {
            ratio = (img1.data.height + img2.data.height) / img1.data.width;
            const padderly = tweetElem.querySelector('div[id^="id_"] div[style^="padding-bottom"]');
            padderly.parentElement.lastElementChild.firstElementChild.style.flexDirection = "column";
        }

        ratio = Math.min(ratio, 3.0);
        ratio *= 100;
    } else if (elemCnt === 3 && mediaElems[0].flex === "row") {
        let img1 = mediaElems[0];
        let img1Ratio = img1.data.height / img1.data.width;
        if (img1Ratio < 1.10 && img1Ratio > 0.9) {
            img1.bgElem.style.backgroundSize = "contain";
        }
    } else if (elemCnt === 4) {
        if (mediaElems[0].data.width > mediaElems[0].data.height &&
            mediaElems[1].data.width > mediaElems[1].data.height &&
            mediaElems[2].data.width > mediaElems[2].data.height &&
            mediaElems[3].data.width > mediaElems[3].data.height) {
            // All-wide 4-panel already has an optimal layout by default.
        } else if (mediaElems[0].data.width > mediaElems[0].data.height) {
            let img1Ratio = mediaElems[0].data.height / mediaElems[0].data.width;
            let img2Ratio = mediaElems[1].data.height / mediaElems[1].data.width;
            let img3Ratio = mediaElems[2].data.height / mediaElems[2].data.width;
            let img4Ratio = mediaElems[3].data.height / mediaElems[3].data.width;
            let minImg = img1Ratio > img2Ratio ? mediaElems[1] : mediaElems[0];

            ratio = (mediaElems[0].data.height + mediaElems[1].data.height) / minImg.data.width;
            ratio *= 100;
        }
    }

    updatePadder(tweetElem, ratio);
    watchForChange(tweetElem, argsChildAndSub, (tweet, mutes) => {
        updatePadder(tweetElem, ratio);
    });

    let edgeCase = getCSSRuleContainingStyle('align-self', ['.r-'], 0, 'flex-start');
    if (edgeCase) {
        edgeCase.style.setProperty('align-self', "inherit");
    }
}


function isAdvert(tweet) {
    let impression = tweet.querySelector('div[data-testid="placementTracking"] div[data-testid$="impression-pixel"]');
    if (impression) {
        tweet.style.display = "none";
        return true;
    }
    return false;
}

const mediaInfoBuffer = new Array(8);
const elemsQueryBuffer = new Array(8);

async function processTweetContent(tweet, tweetData) {
    let medias = tweetData.media;
    let elemsQuery = new Array(medias.length);
    let mediaInfos = new Array(medias.length);

    for (let i = 0; i < medias.length; i++) {
        let mediaData = tweetData.getMediaData(i);

        mediaInfos[i] = { data: mediaData, mediaElem: null, linkElem: null, tweetPhotoElem: null, bgElem: null, flex: null };

        if (mediaData.isPhoto) {
            let srcID = mediaData.media_url.substring(mediaData.media_url.lastIndexOf('/') + 1).split('?')[0].split('.')[0];
            elemsQuery[i] = awaitElem(tweet, `[src*="${srcID}"]`, argsChildAndSub);
        } else {
            elemsQuery[i] = awaitElem(tweet, `video[poster^="${mediaData.media_url.split('?')[0]}"]`, argsChildAndSub);
        }
    }

    Promise.allSettled(elemsQuery).then((values) => {
        for (let i = 0; i < values.length; i++) {
            if (values[i].status === "fulfilled") {
                mediaInfos[i].mediaElem = values[i].value;
            }
        }
        updateContentElements(tweet, tweetData, mediaInfos);
    });
}

function processTweet(tweet, tweetObserver) {
    tweetObserver.disconnect();
    if (tweet == null) { return false; }
    if (tweet.getAttribute(modifiedAttr) != null || tweet.querySelector(`[${modifiedAttr}]`)) { return true; }

    addHasAttribute(tweet, modifiedAttr);

    if (toggleMakeLinksVX.enabled) {
        awaitElem(tweet, 'a:has(> time)', { childList: true, subtree: true, attributes: false }).then((linky) => {
            linky.href = replaceWithVX(linky.href);
        });
    }
    if (isAdvert(tweet)) { return; }

    let tweetData = getTweetData(tweet);
    if (tweetData == null) { return; }

    if (tweetData.hasMedia) { processTweetContent(tweet, tweetData); }
    if (tweetData.isQuote && tweetData.quote.hasMedia) {
        tweetData.quote.tweetElem = tweet;
        processTweetContent(tweet, tweetData.quote);
    }
}

async function listenForMediaType(tweet) {
    if (addHasAttribute(tweet, "thd_observing")) { return; }

    const tweetObserver = new MutationObserver((muteList, observer) => {
        processTweet(tweet, observer);
    });

    processTweet(tweet, tweetObserver);
    tweetObserver.observe(tweet, { attributes: true, childList: true, subtree: true });
}

const topicsFilter = 'a[href^="/i/topics/"]';
const likedFilter = 'a[href^="/i/user/"]';
const followsFilter = 'a[href="/i/timeline"]';

const setupToggle = function (elem, toggle) {
    elem.style.display = toggle.enabled ? "block" : "none";
    toggle.listen((e) => {
        elem.style.display = e.detail.toggle.enabled ? "block" : "none";
    });
}


/*
function setupFilters(tweet) {
    let socialCtx = tweet.querySelector('span[data-testid="socialContext"]');
    if (socialCtx != null) {
        let root = tweet.closest('[data-testid="cellInnerDiv"]');

        let topics = tweet.querySelector(topicsFilter);
        if (topics != null) {
            setupToggle(root, toggleTopics);
            if (!toggleTopics.enabled) {
                root.removeChild(root.firstElementChild);
            }
            return toggleTopics.enabled;
        }

        let followed = tweet.querySelector(followsFilter);
        if (followed != null) {
            setupToggle(root, toggleFollowed);
            if (!toggleFollowed.enabled) {
                root.removeChild(root.firstElementChild);
            }
            return toggleFollowed.enabled;
        }

        let liked = tweet.querySelector(likedFilter);
        if (liked != null) {
            if (liked.href.includes('/user/') && root.firstElementChild.className.split(' ').length < 4) {
                // reply
                return true;
            }
            setupToggle(root, toggleLiked);
            if (!toggleLiked.enabled) {
                root.removeChild(root.firstElementChild);
            }
            return toggleLiked.enabled;
        }

        // Uncomment and implement this part if needed
        // let retweet = tweet.querySelector('a[href^="/"][dir="auto"][role="link"]');
        // if (retweet != null) {
        //     setupToggle(root, toggleRetweet);
        // }

    }
    return true;
}
*/

//<--> COLUMN RESIZING START<-->//
var primaryColumnCursorDistToEdge = 900;
var primaryColumnMouseDownPos = 0;
var primaryColumnResizing = false;
var primaryColumnPreWidth = 600;
var maxWidthClass = null;
var preCursor;
var headerColumn = null;

function primaryColumnResizer(primaryColumn, mouseEvent, mouseDown, mouseUp) {
    if (mouseDown && mouseEvent.button !== 0) { return; }
    let primaryRect = primaryColumn.getBoundingClientRect();
    let localPosX = mouseEvent.clientX - primaryRect.left;
    primaryColumnCursorDistToEdge = Math.abs(primaryRect.width - localPosX);

    if (mouseUp || primaryColumnCursorDistToEdge > 180) {
        primaryColumnResizing = false;
        if (mouseUp) {
            let primarySize = parseInt(maxWidthClass.style.getPropertyValue('max-width'));
            updateLayoutWidth(primarySize, true);
        }
    }

    if (primaryColumnCursorDistToEdge < 6 || primaryColumnResizing) {
        preCursor = document.body.style.cursor;
        document.body.style.cursor = "ew-resize";
        if (mouseDown) {
            primaryColumnMouseDownPos = mouseEvent.pageX;
            primaryColumnResizing = true;
            primaryColumnPreWidth = parseInt(maxWidthClass.style.getPropertyValue('max-width'));
        }
    } else {
        document.body.style.cursor = (preCursor === "ew-resize") ? "auto" : preCursor;
    }

    if (primaryColumnResizing) {
        mouseEvent.preventDefault();
        let columnOffset = mouseEvent.pageX - primaryColumnMouseDownPos;
        let newColumnSize = primaryColumnPreWidth + columnOffset;
        newColumnSize = Math.max(250, newColumnSize);
        updateLayoutWidth(newColumnSize);
    }
}

var curLayoutWidth = 600;

function updateLayoutWidth(width, finalize) {
    curLayoutWidth = width;
    if (!toggleTimelineScaling.enabled) { return; }

    maxWidthClass.style.setProperty('max-width', width + "px");
    if (finalize) {
        headerColumn = document.body.querySelector('HEADER');
        if (headerColumn) {
            headerColumn.style.flexGrow = 0.2;
            headerColumn.style.webkitBoxFlex = 0.2;
        }
        setUserPref(usePref_MainWidthKey, width);
    }
}

function refreshLayoutWidth() {
    let width = getUserPref(usePref_MainWidthKey, 600);
    updateLayoutWidth(width, true);
}
//<--> COLUMN RESIZING END <-->//


//<--> TIMELINE PROCESSING <-->//
async function onTimelineContainerChange(container, mutations) {
    replaceMuskratText(container);
    LogMessage("on timeline container change");
    let tl = await awaitElem(container, 'DIV[style*="position:"]', { childList: true, subtree: true, attributes: true });
    observeTimeline(tl);
}

function onTimelineChange(addedNodes) {
    if (addedNodes.length === 0) {
        LogMessage("no added nodes");
        return;
    }
    addedNodes.forEach((child) => {
        awaitElem(child, 'ARTICLE', argsChildAndSub).then(listenForMediaType);
    });
}

function observeTimeline(tl) {
    if (!addHasAttribute(tl, "thd_observing_timeline")) {
        LogMessage("starting timeline observation");
        const childNodes = Array.from(tl.childNodes);
        onTimelineChange(childNodes);

        watchForAddedNodes(tl, false, { attributes: false, childList: true, subtree: false }, onTimelineChange);
    }
}


async function watchForTimeline(primaryColumn) {
    let section = await awaitElem(primaryColumn, 'section[role="region"]', argsChildAndSub);

    if (addHasAttribute(section, modifiedAttr)) { return; }

    if (!addHasAttribute(section.parentElement, modifiedAttr)) {
        watchForAddedNodes(section.parentElement, false, { attributes: false, childList: true, subtree: false }, (addedNodes, mutes) => {
            watchForTimeline(primaryColumn);
        });
    }

    const checkTimeline = async function () {
        let tl = await awaitElem(section, 'DIV[style*="position:"]', { childList: true, subtree: true, attributes: true });
        let progBar = tl.querySelector('[role="progressbar"]');
        if (progBar) {
            // Wait for an Article to show up before proceeding
            // LogMessage("Has Prog Bar, Awaiting Article");
            let art = await awaitElem(section, "article", { childList: true, subtree: true, attributes: true });
            // LogMessage("Found Article");
        }

        let tlContainer = tl.parentElement;
        if (!addHasAttribute(tlContainer, "thd_observing_timeline")) {
            observeTimeline(tl);
            watchForChange(tlContainer, { attributes: false, childList: true }, (tlc, mutes) => { onTimelineContainerChange(tlc, mutes); });
        }
    };

    checkTimeline();

    let progBarObserver = new MutationObserver((mutations) => {
        progBarObserver.disconnect();
        checkTimeline();
        progBarObserver.observe(section, { attributes: false, childList: true });
    });
    progBarObserver.observe(section, { attributes: false, childList: true });
}

var pageWidthLayoutRule;

async function watchPrimaryColumn(main, primaryColumn) {
    if (primaryColumn == null) { return; }

    awaitElem(primaryColumn, 'nav', argsChildAndSub).then((nav) => {
        let navCont = nav.parentElement;
        if (addHasAttribute(navCont, modifiedAttr)) { return; }
        watchForChange(navCont, argsChildOnly, () => { watchForTimeline(primaryColumn, navCont); });
    });

    if (!addHasAttribute(primaryColumn.firstElementChild, modifiedAttr)) {
        // Watch to handle case where timelines are partially lost when clicking on the quoted post name.
        watchForChange(primaryColumn.firstElementChild, argsChildOnly, () => {
            watchForTimeline(primaryColumn);
        });
    }

    if (addHasAttribute(primaryColumn, modifiedAttr)) { return; }
    hideForYou(primaryColumn);

    if (pageWidthLayoutRule == null) {
        pageWidthLayoutRule = getCSSRuleContainingStyle('width', (("." + main.className).replace(' ', ' .')).split(' '));
    }

    if (toggleTimelineScaling.enabled) {
        pageWidthLayoutRule.style.setProperty('width', "100%");

        let primaryColumnGrp = primaryColumn.parentElement.parentElement;
        let columnClassNames = ("." + primaryColumn.className.replace(" ", " .")).split(' ');

        maxWidthClass = getCSSRuleContainingStyle("max-width", columnClassNames);
        getUserPref(usePref_MainWidthKey, 600).then((userWidth) => updateLayoutWidth(userWidth, true));

        primaryColumnGrp.addEventListener('mousemove', (e) => { primaryColumnResizer(primaryColumn, e, false, false) });
        primaryColumnGrp.addEventListener('mousedown', (e) => { primaryColumnResizer(primaryColumn, e, true, false) });
        window.addEventListener('mouseup', (e) => { primaryColumnResizer(primaryColumn, e, false, true) });
        document.addEventListener('mouseup', (e) => { primaryColumnResizer(primaryColumn, e, false, true) });
    }

    watchForTimeline(primaryColumn);
}

async function onMainChange(main, mutations) {
    replaceMuskratText(document.body);
    awaitElem(main, 'div[data-testid="primaryColumn"]', argsChildAndSub).then((primaryColumn) => {
        watchPrimaryColumn(main, primaryColumn);
        replaceMuskratText(document.body);
    });

    watchSideBar(main);
}
/**
 * Replaces "Post" with "Tweet" and "Posts" with "Tweets" in the text content of all relevant spans.
 * @param {HTMLElement} root - The root element to search within.
 */
function replaceMuskratText(root) {
    let labels = root.querySelectorAll('span, span > span');

    for (let i = 0; i < labels.length; i++) {
        let label = labels[i];
        if (label.innerText === "Post") {
            label.innerText = "Tweet";
        } else if (label.innerText === "Posts") {
            label.innerText = "Tweets";
        }
    }
}

/**
 * Hides the "For You" tab and clicks on the "Following" tab if the "For You" tab is present.
 * @param {HTMLElement} primaryColumn - The primary column containing the tabs.
 */
function hideForYou(primaryColumn) {
    if (!toggleDisableForYou.enabled) { return; }

    let mainTabs = primaryColumn.querySelector('div[role="tablist"]');
    if (mainTabs) {
        let tabs = mainTabs.querySelectorAll('div[role="presentation"] > a[href="/home"]');
        if (tabs.length > 1) {
            tabs[0].parentElement.style.display = 'none';
            tabs[1].parentElement.click();
        }
    }
}

//<--> RIGHT SIDEBAR CONTENT <-->//

//<--> Save/Load User Custom Preferences <-->//
const usePref_MainWidthKey = "thd_primaryWidth";
const usePref_hideTrendingKey = "thd_hideTrending";
const usePref_lastTopicsClearTime = "thd_lastTopicsClearTime";

var toggleNSFW;
var toggleHQImg;
var toggleHQVideo;
var toggleLiked;
var toggleFollowed;
var toggleRetweet;
var toggleTopics;
var toggleClearTopics;
var toggleTimelineScaling;
var toggleAnalyticsDisplay;
var toggleDisableForYou;
var toggleMakeLinksVX;

var prefsLoaded = false;

/**
 * Watches for changes in the sidebar and sets up necessary controls and toggles.
 * @param {HTMLElement} main - The main container element.
 */
async function watchSideBar(main) {
    await awaitElem(main, 'div[data-testid="sidebarColumn"]', argsChildAndSub).then((sideBar) => {
        awaitElem(sideBar, 'section[role="region"] > [role="heading"]', argsChildAndSub).then((sideBarTrending) => {
            setupTrendingControls(sideBarTrending.parentElement);
            setupToggles(sideBar);
            clearTopicsAndInterests();
        });
    });
}

/**
 * Retrieves a toggle object for a given preference name and default value.
 * @param {string} name - The name of the preference.
 * @param {boolean} defaultVal - The default value of the preference.
 * @returns {Object} - The toggle object with properties and methods for managing the preference.
 */
async function getToggleObj(name, defaultVal) {
    let enable = await getUserPref(name, defaultVal);
    return {
        enabled: enable,
        elem: null,
        name: name,
        onChanged: new EventTarget(),
        listen: function(func) {
            this.onChanged.addEventListener(this.name, func);
        }
    };
}

// NSFW Blur Button Selectors
const nsfwBlurBtnSelector = 'div[role="button"][style*="backdrop-filter: blur(4px);"][style*="background-color:"]';
const nsfwBlurBtnSubSelector = 'div[dir="ltr"] > span > span';
const nsfwBlurBtnElemQuery = `${nsfwBlurBtnSelector}:has(> ${nsfwBlurBtnSubSelector})`;
const nsfwBlurBtnElemSelector = `${nsfwBlurBtnSelector} > ${nsfwBlurBtnSubSelector}`;
const nsfwBlurRootQuery = `div:has(> div > div > ${nsfwBlurBtnElemSelector}):has(div[data-testid="tweetPhoto"])`;
const nsfwBlurUIQuery = `${nsfwBlurRootQuery} > div:has(${nsfwBlurBtnSelector}):has(${nsfwBlurBtnSubSelector})`;
const nsfwBlurBtnQuery = `${nsfwBlurRootQuery} ${nsfwBlurBtnElemQuery}`;
const nsfwBlurFilterQuery = `${nsfwBlurRootQuery} > div:has(div[data-testid="tweetPhoto"])`;

/**
 * Toggles the NSFW blur style on or off.
 * @param {boolean} enabled - Whether to enable or disable the blur style.
 */
function toggle_nsfwBlurStyle(enabled) {
    if (!enabled) {
        addGlobalStyle(
            `div[aria-label^="Timeline:"] div[data-testid="cellInnerDiv"] li[role="listitem"] div:has(> div > svg > g > path) > div:has(img) {
                -webkit-filter: blur(0px) !important;
                filter: blur(0px) !important;
            }
            div[aria-label^="Timeline:"] div[data-testid="cellInnerDiv"] li[role="listitem"] div:has(> svg > g > path) {
                display: none !important;
            }
            article[data-testid="tweet"] div[aria-labelledby^="id_"] :not([tabindex]) > div:has(> div > div > div[role="button"][style*="blur"]) {
                > div:not(:has(div[data-testid^="tweet"]), :has([style^="transition-d"] > [aria-label])) { display: none !important; }
                > div > div > div[role="button"] { display: none !important; }
                > div:has(div[data-testid^="tweet"]) { -webkit-filter: none !important; filter: none !important; }
            }`,
            "nsfwblur"
        );
    }
    if (enabled) {
        removeGlobalStyle("nsfwblur");
    }
}

/*
article[data-testid="tweet"] div[aria-labelledby^="id_"] [data-testid="videoComponent"] > div[tabindex]:has([style^="transition-d"] > [aria-label]) {
    display: none !important;
}
*/

/**
 * Load and set user preferences for toggles.
 */
async function loadToggleValues() {
    if (prefsLoaded === true) { return; }

    // Load toggle preferences
    await Promise.allSettled([
        (async () => { toggleNSFW = await getToggleObj("thd_blurNSFW", false); })(),
        (async () => { toggleHQImg = await getToggleObj("thd_toggleHQImg", true); })(),
        (async () => { toggleHQVideo = await getToggleObj("thd_toggleHQVideo", true); })(),
        (async () => { toggleLiked = await getToggleObj("thd_toggleLiked", true); })(),
        (async () => { toggleFollowed = await getToggleObj("thd_toggleFollowed", false); })(),
        (async () => { toggleRetweet = await getToggleObj("thd_toggleRetweet", false); })(),
        (async () => { toggleTopics = await getToggleObj("thd_toggleTopics", false); })(),
        (async () => { toggleClearTopics = await getToggleObj("thd_toggleClearTopics", false); })(),
        (async () => { toggleTimelineScaling = await getToggleObj("thd_toggleTimelineScaling", true); })(),
        (async () => { toggleAnalyticsDisplay = await getToggleObj("thd_toggleAnalyticsDisplay", false); })(),
        (async () => { toggleDisableForYou = await getToggleObj("thd_disableForYou", false); })(),
        (async () => { toggleMakeLinksVX = await getToggleObj("thd_makeLinksVX", true); })()
    ]);

    prefsLoaded = true;

    // Apply analytics display preference
    if (!toggleAnalyticsDisplay.enabled) {
        addGlobalStyle('div[role="group"] > div:has(> a[href$="/analytics"]) { display: none !important; }', "analyticsStyle");
    }
    toggleAnalyticsDisplay.onChanged.addEventListener(toggleAnalyticsDisplay.name, () => {
        if (!toggleAnalyticsDisplay.enabled) {
            addGlobalStyle('div[role="group"] > div:has(> a[href$="/analytics"]) { display: none !important; }', "analyticsStyle");
        } else {
            removeGlobalStyle("analyticsStyle");
        }
    });

    // Apply NSFW blur style
    toggleNSFW.onChanged.addEventListener(toggleNSFW.name, () => {
        toggle_nsfwBlurStyle(toggleNSFW.enabled);
    });
    toggle_nsfwBlurStyle(toggleNSFW.enabled);
}

/**
 * Sets up toggle options in the sidebar.
 * @param {HTMLElement} sidePanel - The sidebar element to append toggle options to.
 */
async function setupToggles(sidePanel) {
    if (sidePanel.querySelector('.thd_settings_collapsible')) { return; }

    sidePanel = sidePanel.querySelector('div:has(> nav)');

    // Create and append settings button and container
    let settingsFold = document.createElement('button');
    settingsFold.className = 'thd_settings_collapsible';
    settingsFold.innerText = "Twitter AutoHD Settings:";
    let settingsContainer = document.createElement('div');
    settingsContainer.className = 'thd_settings_content thd_settings_content_closed';
    sidePanel.appendChild(settingsFold);
    sidePanel.appendChild(settingsContainer);
    sidePanel = settingsContainer;

    // Toggle settings container visibility
    settingsFold.addEventListener("click", function() {
        this.classList.toggle("thd_settings_active");
        let content = this.nextElementSibling;
        content.classList.toggle('thd_settings_content_closed');
    });

    // Create toggle options
    createToggleOption(sidePanel, toggleNSFW, "NSFW Blur: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleHQImg, "HQ Image Loading: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleHQVideo, "HQ Video Loading: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleTimelineScaling, "Timeline Width Scaling: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleMakeLinksVX, "Replace Links with VX Link: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleLiked, "Liked Tweets: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleFollowed, "Followed By Tweets: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleRetweet, "Retweets: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleTopics, "Topic Tweets: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleClearTopics, "Interests/Topics Prefs AutoClear: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleAnalyticsDisplay, "Show Post Views: ", "ON", "OFF");
    createToggleOption(sidePanel, toggleDisableForYou, 'Disable "For You" page: ', "ON", "OFF");
}

function createToggleOption(sidePanel, toggleState, toggleText, toggleOnText, toggleOffText) {
    toggleState.elem = sidePanel.querySelector('#' + toggleState.name);
    toggleOnText = toggleText + toggleOnText;
    toggleOffText = toggleText + toggleOffText;

    if (toggleState.elem == null) {
        toggleState.elem = createToggleButton(toggleState.enabled ? toggleOnText : toggleOffText, toggleState.name);
        toggleState.elem.classList.toggle("thd_settings_toggle_enabled", toggleState.enabled);

        toggleState.elem.addEventListener('click', (e) => {
            toggleState.enabled = !toggleState.enabled;
            toggleState.elem.classList.toggle("thd_settings_toggle_enabled", toggleState.enabled);
            setUserPref(toggleState.name, toggleState.enabled);
            toggleState.onChanged.dispatchEvent(new CustomEvent(toggleState.name, { 'detail': { 'toggle': toggleState } }));
            toggleState.elem.textContent = toggleState.enabled ? toggleOnText : toggleOffText; // Use textContent
        }, false);

        sidePanel.appendChild(toggleState.elem);
    }
}

var blurShowText = "";

/**
 * Handles the NSFW blur button for tweets based on the toggle state.
 * @param {HTMLElement} tweet - The tweet element.
 */
async function processBlurButton(tweet) {
    const getBlurText = function(blur) {
        return blur.querySelector('span > span').textContent; // Use textContent
    }

    const blurBtn = tweet.querySelector(nsfwBlurBtnQuery);
    if (blurBtn != null) {
        if (blurShowText == "") {
            blurShowText = getBlurText(blurBtn);
        }
        if (!toggleNSFW.enabled) {
            blurBtn.click();
        }
        blurBtn.style.display = toggleNSFW.enabled ? "block" : "none";

        watchForChange(tweet, { attributes: false, childList: true, subtree: true }, (blurParent, mutes) => {
            let curBlur = blurParent.querySelector(nsfwBlurBtnQuery);
            if (curBlur == null) { return; }

            if (!toggleNSFW.enabled && getBlurText(curBlur) == blurShowText) {
                curBlur.click();
            }

            curBlur.style.display = toggleNSFW.enabled ? "block" : "none";
            let span = curBlur.querySelector('span > span');

            if (!addHasAttribute(curBlur, modifiedAttr)) {
                watchForChange(curBlur, { attributes: true, characterData: true, childList: true, subtree: true }, (blur, mutes) => {
                    curBlur = tweet.querySelector(nsfwBlurBtnQuery);
                    if (curBlur) {
                        curBlur.style.display = toggleNSFW.enabled ? "block" : "none";
                    }
                });
                toggleNSFW.onChanged.addEventListener("nsfwToggleChanged", function() {
                    curBlur = tweet.querySelector(nsfwBlurBtnQuery);
                    if (curBlur) {
                        curBlur.click();
                        curBlur.style.display = toggleNSFW.enabled ? "block" : "none";
                    }
                });
            }
        });
    }
}

/**
 * Sets up controls for trending topics.
 * @param {HTMLElement} trendingBox - The trending topics container element.
 */
async function setupTrendingControls(trendingBox) {
    const showStr = "Show";
    const hideStr = "Hide";

    const setTrendingVisible = function (container, button, hidden) {
        container.style.maxHeight = hidden ? "44px" : "none";
        button.textContent = hidden ? showStr : hideStr; // Use textContent
        setUserPref(usePref_hideTrendingKey, hidden);
    };

    let trendingTitle = await awaitElem(trendingBox, 'h2', argsChildAndSub);

    if (!addHasAttribute(trendingTitle, modifiedAttr)) {
        let toggle = trendingTitle.querySelector('#thd_toggleTrending');

        if (toggle == null) {
            toggle = createToggleButton(hideStr, "thd_toggleTrending");
            toggle.addEventListener('click', (e) => {
                let isHidden = toggle.textContent == hideStr; // Use textContent
                setTrendingVisible(trendingBox, toggle, isHidden);
            });
            trendingTitle.appendChild(toggle);
        }
        getUserPref(usePref_hideTrendingKey, true).then((visible) => {
            setTrendingVisible(trendingBox, toggle, visible);
            watchForChange(trendingBox, argsChildAndSub, setupTrendingControls);
        });
    }
}

/**
 * Creates a toggle button with specified text and ID.
 * @param {string} text - The text displayed on the button.
 * @param {string} id - The ID assigned to the button.
 * @returns {HTMLElement} - The created button element.
 */
function createToggleButton(text, id) {
    const btn = document.createElement('button');
    btn.textContent = text; // Use textContent for better security
    btn.id = id;
    btn.className = 'thd_settings_toggle';
    return btn;
}

/**
 * Watches for comments in the dialog and sets up the observer.
 * @param {HTMLElement} dialog - The dialog element.
 */
async function watchForComments(dialog) {
    try {
        let commentList = await awaitElem(dialog, 'div[style^="position: relative"]', argsChildAndSub);
        observeTimeline(commentList); // Ensure observeTimeline is correctly defined
    } catch (error) {
        console.error('Error watching for comments:', error);
    }
}

/**
 * Handles changes in layers and updates full-screen image views.
 * @param {MutationRecord[]} layers - The mutation records.
 * @param {MutationRecord} mutation - The specific mutation record.
 */
async function onLayersChange(layers, mutation) {
    if (mutation.addedNodes.length > 0) {
        const contentContainer = Array.from(mutation.addedNodes)[0];
        if (addHasAttribute(contentContainer, 'thd_modified')) return;

        try {
            const dialog = await awaitElem(contentContainer, 'div[role="dialog"]', argsChildAndSub);
            await watchForComments(dialog);

            let ctxTarget = await awaitElem(dialog, 'img[alt="Image"],div[data-testid="videoPlayer"]', argsChildAndSub);

            const list = dialog.querySelector('ul[role="list"]');
            let id = getIDFromURL(window.location.href);
            let tweetData = tweets.get(id);
            if (!tweetData) return;

            if (list) {
                const listItems = list.querySelectorAll('li');
                for (let i = 0; i < listItems.length; i++) {
                    ctxTarget = await awaitElem(listItems[i], 'img[alt="Image"],div[data-testid="videoPlayer"]', argsChildAndSub);
                    let mediaData = tweetData.getMediaData(i);
                    if (mediaData) {
                        await updateFullViewImage(ctxTarget, tweetData, mediaData);
                    }
                }
            } else {
                let mediaData = tweetData.getMediaData(0);
                if (mediaData) {
                    await updateFullViewImage(ctxTarget, tweetData, mediaData);
                }
            }
        } catch (error) {
            console.error('Error processing layers change:', error);
        }
    }
}

/**
 * Updates the full view image with high-quality source if enabled.
 * @param {HTMLElement} ctxTarget - The target image or video element.
 * @param {Object} tweetData - The tweet data object.
 * @param {Object} mediaData - The media data object.
 */
async function updateFullViewImage(ctxTarget, tweetData, mediaData) {
    try {
        let bg = ctxTarget.parentElement.querySelector('div') ?? ctxTarget.parentElement;
        let mediaInfo = { data: mediaData, linkElem: ctxTarget, mediaElem: ctxTarget };

        addCustomCtxMenu(tweetData, mediaInfo, ctxTarget);
        if (toggleHQImg.enabled && !mediaData.isVideo) {
            let hqSrc = mediaData.getContentURL();
            updateImgSrc(ctxTarget, bg, hqSrc);
            doOnAttributeChange(ctxTarget, (ctxTarg) => {
                updateImgSrc(ctxTarg, bg, hqSrc);
            }, false);
        }
    } catch (error) {
        console.error('Error updating full view image:', error);
    }
}
// <--> RIGHT-CLICK CONTEXT MENU STUFF START <--> //
let ctxMenu;
let ctxMenuList;
let ctxMenuOpenInNewTab;
let ctxMenuOpenVidInNewTab;
let ctxMenuSaveAs;
let ctxMenuSaveAsVid;
let ctxMenuCopyImg;
let ctxMenuCopyAddress;
let ctxMenuCopyVidAddress;
let ctxMenuGRIS;
let ctxMenuGoogleLens;
let ctxMenuShowDefault;

function initializeCtxMenu() {
    ctxMenu = document.createElement('div');
    ctxMenu.style.zIndex = "500";
    ctxMenu.id = "contextMenu";
    ctxMenu.className = "context-menu";
    ctxMenuList = document.createElement('ul');
    ctxMenu.appendChild(ctxMenuList);

    ctxMenuOpenInNewTab = createCtxMenuItem(ctxMenuList, "Open in New Tab");
    ctxMenuOpenVidInNewTab = createCtxMenuItem(ctxMenuList, "Open in New Tab");
    ctxMenuSaveAs = createCtxMenuItem(ctxMenuList, "Save Image As");
    ctxMenuSaveAsVid = createCtxMenuItem(ctxMenuList, "Save Video As");
    ctxMenuCopyImg = createCtxMenuItem(ctxMenuList, "Copy Image");
    ctxMenuCopyAddress = createCtxMenuItem(ctxMenuList, "Copy Image Link");
    ctxMenuCopyVidAddress = createCtxMenuItem(ctxMenuList, "Copy Video Link");
    ctxMenuGRIS = createCtxMenuItem(ctxMenuList, "Search Google");
    ctxMenuGoogleLens = createCtxMenuItem(ctxMenuList, "SGoogle Lens");
    ctxMenuShowDefault = createCtxMenuItem(ctxMenuList, "Default Context Menu");

    document.body.appendChild(ctxMenu);
    document.body.addEventListener('click', () => setContextMenuVisible(false));
    setContextMenuVisible(false);

    window.addEventListener('locationchange', () => setContextMenuVisible(false));
    window.addEventListener('popstate', () => setContextMenuVisible(false));
}

function createCtxMenuItem(menuList, text) {
    const menuItem = document.createElement('li');
    menuItem.innerText = text;
    menuList.appendChild(menuItem);
    return menuItem;
}

function mouseX(evt) {
    return evt.pageX || evt.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
}

function mouseY(evt) {
    return evt.pageY || evt.clientY + (document.documentElement.scrollTop || document.body.scrollTop);
}

function setContextMenuVisible(visible) {
    ctxMenu.style.display = visible ? "block" : "none";
}

let selectedShowDefaultContext = false;

function wasShowDefaultContextClicked() {
    return selectedShowDefaultContext;
}

async function updateContextMenuLink(tweetData, mediaInfo) {
    if (!mediaInfo) return;

    ctxMenu.setAttribute('selection', mediaInfo.data.media_id);

    const isImage = mediaInfo.mediaElem.tagName.toLowerCase() === "img";
    const imgVisibility = isImage ? "block" : "none";
    const vidVisibility = isImage ? "none" : "block";

    ctxMenuOpenInNewTab.style.display = imgVisibility;
    ctxMenuSaveAs.style.display = imgVisibility;
    ctxMenuCopyImg.style.display = imgVisibility;
    ctxMenuCopyAddress.style.display = imgVisibility;
    ctxMenuGRIS.style.display = imgVisibility;
    ctxMenuGoogleLens.style.display = imgVisibility;

    ctxMenuOpenVidInNewTab.style.display = vidVisibility;
    ctxMenuSaveAsVid.style.display = vidVisibility;
    ctxMenuCopyVidAddress.style.display = vidVisibility;

    const copyAddress = async (url) => {
        setContextMenuVisible(false);
        await navigator.clipboard.writeText(url);
    };

    const saveMedia = async (url) => {
        setContextMenuVisible(false);
        try {
            await download(url, filenameFromMediaData(mediaInfo.data));
        } catch (err) {
            console.error("Failed to download media:", err);
        }
    };

    const openInNewTab = (url) => {
        setContextMenuVisible(false);
        if (GM_OpenInTabMissing) {
            window.open(url, '_blank').focus();
        } else {
            GM_openInTab(url, { active: false, insert: true, setParent: true, incognito: false });
        }
    };

    if (isImage) {
        mediaInfo.mediaElem.crossOrigin = 'Anonymous';

        ctxMenuOpenInNewTab.onclick = () => openInNewTab(mediaInfo.data.getContentURL());
        ctxMenuSaveAs.onclick = () => saveMedia(mediaInfo.data.getContentURL());
        ctxMenuCopyImg.onclick = async () => {
            setContextMenuVisible(false);
            try {
                const canvas = document.createElement('canvas');
                canvas.width = mediaInfo.data.width;
                canvas.height = mediaInfo.data.height;
                canvas.getContext('2d').drawImage(mediaInfo.mediaElem, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(async (blob) => {
                    await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
                }, "image/png", 1);
            } catch (err) {
                console.error("Failed to copy image:", err);
            }
        };
        ctxMenuCopyAddress.onclick = () => copyAddress(mediaInfo.data.getContentURL());
        ctxMenuGRIS.onclick = () => {
            setContextMenuVisible(false);
            window.open(`https://www.google.com/searchbyimage?sbisrc=cr_1_5_2&image_url=${mediaInfo.data.getContentURL()}`);
        };
        ctxMenuGoogleLens.onclick = () => {
            setContextMenuVisible(false);
            window.open(`https://lens.google.com/uploadbyurl?url=${mediaInfo.data.getContentURL()}`);
        };
    } else {
        ctxMenuOpenVidInNewTab.onclick = () => openInNewTab(mediaInfo.data.getContentURL());

        if (!mediaInfo.mediaElem.hasAttribute("downloading")) {
            ctxMenuSaveAsVid.onclick = async () => {
                mediaInfo.mediaElem.setAttribute("downloading", "");
                await saveMedia(mediaInfo.data.getContentURL());
                mediaInfo.mediaElem.removeAttribute("downloading");
            };
        } else {
            ctxMenuSaveAsVid.style.display = "none";
        }

        ctxMenuCopyVidAddress.onclick = () => copyAddress(mediaInfo.data.getContentURL());
    }

    ctxMenuShowDefault.onclick = () => {
        selectedShowDefaultContext = true;
        setContextMenuVisible(false);
    };
}

function addCustomCtxMenu(tweetData, mediaInfo, ctxTarget) {
    if (ctxTarget.hasAttribute("thd_customctx")) return;

    ctxTarget.setAttribute("thd_customctx", "");

    ctxTarget.addEventListener('contextmenu', (e) => {
        e.stopPropagation();

        const curSel = ctxMenu.getAttribute('selection');

        if (wasShowDefaultContextClicked()) {
            selectedShowDefaultContext = false;
            return;
        }

        e.preventDefault();

        if (ctxMenu.style.display !== "block" || !curSel || curSel !== mediaInfo.data.media_id) {
            updateContextMenuLink(tweetData, mediaInfo);
            setContextMenuVisible(true);
            ctxMenu.style.left = `${mouseX(e) - 12}px`;
            ctxMenu.style.top = `${mouseY(e) - 10}px`;
        } else {
            setContextMenuVisible(false);
        }
    }, { capture: true });
}

//<--> TWITTER UTILITY FUNCTIONS <-->//

//Because Firefox doesn't assume the format unlike Chrome...
function getMediaFormat(url) {
    const urlObj = new URL(url);
    const extension = urlObj.pathname.split('.').pop();
    return extension ? '.' + extension.split('?')[0] : '';
}


function isDirectImagePage(url) {
    if (url.includes('pbs.twimg.com/media/') && !url.includes('name=orig')) {
        window.location.replace(getHighQualityImage(url));
        return true;
    }
    return false;
}


function download(url, filename) {
    return new Promise((resolve, reject) => {
        try {
            GM_download({
                name: filename + getMediaFormat(url),
                url: url,
                onload: resolve,
                onerror: reject,
                ontimeout: reject
            });
        } catch (error) {
            reject(error);
        }
    });
}


function getUrlFromTweet(tweet) {
    const article = tweet.tagName.toUpperCase() === 'ARTICLE' ? tweet : tweet.querySelector('article');
    if (!article) return null;
    const timeElem = article.querySelector('time');
    if (timeElem && timeElem.parentElement.tagName.toUpperCase() === 'A') {
        return timeElem.parentElement.href;
    }
    const postLink = article.querySelector('a[href*="/status/"][role="link"][dir="auto"]');
    return postLink ? postLink.href : null;
}


function getIDFromTweet(tweet)
{
    let url = getUrlFromTweet(tweet);
    return getIDFromURL(url);
}

function getIDFromURL(url) {
    if (!url) return null;
    const match = url.match(/status\/(\d+)/);
    return match ? match[1] : null;
}


function getTweetData(tweet)
{
     let id = getIDFromTweet(tweet);
    if (id == null) { return null; }

    let tweetData = tweets.get(id);

    if(tweetData == null) { return null; }

    return tweetData;
}

function filenameFromMediaData(mediaData)
{
    let filename = mediaData.username + ' - ' + mediaData.id;
    if (mediaData.mediaNum >= 0) { filename += '_' + mediaData.mediaNum.toString(); }
    return filename;
}

function getHighQualityImage(url)
{
    if(!url.includes("name=")) { return url + (url.includes('?') ? '&' : '?') + 'name=orig'; }
    return url.replace(/(?<=[\&\?]name=)([A-Za-z0-9])+(?=\&)?/, 'orig');
}


//--> PREFERENCE UPDATING <--//
var clearedTopics = false;

async function clearTopicsAndInterests(force = false) {
    if (!force && clearedTopics) return;
    clearedTopics = true;

    const autoClear = await getUserPref(toggleClearTopics.name, false);
    if (!autoClear && !force) return;

    const lastClearTimeText = await getUserPref(usePref_lastTopicsClearTime, "16");
    const lastClearTime = parseInt(lastClearTimeText);
    const curTime = Date.now();

    if (curTime - lastClearTime < 86400000) return;

    await setUserPref(usePref_lastTopicsClearTime, curTime.toString());

    try {
        const interestsResponse = await fetch("https://twitter.com/i/api/1.1/account/personalization/twitter_interests.json", {
            headers: {
                accept: "*/*",
                "accept-language": "en-US,en;q=0.9",
                authorization: authy,
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "x-csrf-token": cooky,
                "x-twitter-active-user": "yes",
                "x-twitter-auth-type": "OAuth2Session",
                "x-twitter-client-language": "en"
            },
            referrer: "https://twitter.com/settings/your_twitter_data/twitter_interests",
            referrerPolicy: "strict-origin-when-cross-origin",
            method: "GET",
            mode: "cors",
            credentials: "include"
        });

        if (interestsResponse.status === 200) {
            const json = await interestsResponse.json();
            const prefsResponse = await fetch("https://twitter.com/i/api/1.1/account/personalization/p13n_preferences.json", {
                headers: {
                    accept: "*/*",
                    "accept-language": "en-US,en;q=0.9",
                    authorization: authy,
                    "sec-fetch-dest": "empty",
                    "sec-fetch-mode": "cors",
                    "sec-fetch-site": "same-origin",
                    "x-csrf-token": cooky,
                    "x-twitter-active-user": "yes",
                    "x-twitter-auth-type": "OAuth2Session",
                    "x-twitter-client-language": "en"
                },
                referrer: "https://twitter.com/settings/your_twitter_data/twitter_interests",
                referrerPolicy: "strict-origin-when-cross-origin",
                method: "GET",
                mode: "cors",
                credentials: "include"
            });

            if (prefsResponse.status === 200) {
                const prefs = await prefsResponse.json();
                const interests = json.interested_in;
                if (interests.length === 0) return;

                const disinterests = prefs.interest_preferences.disabled_interests;
                prefs.allow_ads_personalization = false;
                prefs.use_cookie_personalization = false;
                prefs.is_eu_country = true;
                prefs.age_preferences.use_age_for_personalization = false;
                prefs.gender_preferences.use_gender_for_personalization = false;

                interests.forEach(interest => disinterests.push(interest.id));
                prefs.interest_preferences.disabled_interests = disinterests;

                await fetch("https://twitter.com/i/api/1.1/account/personalization/p13n_preferences.json", {
                    headers: {
                        authorization: authy,
                        "content-type": "application/json",
                        "x-csrf-token": cooky,
                        "x-twitter-active-user": "yes",
                        "x-twitter-auth-type": "OAuth2Session",
                        "x-twitter-client-language": "en"
                    },
                    referrer: "https://twitter.com/settings/your_twitter_data/twitter_interests",
                    referrerPolicy: "strict-origin-when-cross-origin",
                    body: JSON.stringify({ preferences: prefs }),
                    method: "POST",
                    mode: "cors",
                    credentials: "include"
                });
            }
        }

        const topicsResponse = await fetch("https://twitter.com/i/api/graphql/Lt9WPkNBUP-LtG_OPW9FkA/TopicsManagementPage?variables=%7B%22withSuperFollowsUserFields%22%3Afalse%2C%22withDownvotePerspective%22%3Afalse%2C%22withReactionsMetadata%22%3Afalse%2C%22withReactionsPerspective%22%3Afalse%2C%22withSuperFollowsTweetFields%22%3Atrue%7D&features=%7B%22responsive_web_twitter_blue_verified_badge_is_enabled%22%3Afalse%2C%22verified_phone_label_enabled%22%3Afalse%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22unified_cards_ad_metadata_container_dynamic_card_content_query_enabled%22%3Atrue%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_uc_gql_enabled%22%3Atrue%2C%22vibe_api_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Afalse%2C%22interactive_text_enabled%22%3Atrue%2C%22responsive_web_text_conversations_enabled%22%3Afalse%2C%22responsive_web_enhance_cards_enabled%22%3Atrue%7D", {
            headers: {
                accept: "*/*",
                "accept-language": "en-US,en;q=0.9",
                authorization: authy,
                "content-type": "application/json",
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "x-csrf-token": cooky,
                "x-twitter-active-user": "yes",
                "x-twitter-auth-type": "OAuth2Session",
                "x-twitter-client-language": "en"
            },
            referrer: window.location.href,
            referrerPolicy: "strict-origin-when-cross-origin",
            method: "GET",
            mode: "cors",
            credentials: "include"
        });

        if (topicsResponse.status === 200) {
            const topics = await topicsResponse.json();
            const items = topics.data.viewer.topics_management_page.body.initialTimeline.timeline.timeline.instructions[2].entries;

            for (const item of items) {
                if (item.content.clientEventInfo.component === "suggest_followed_topic" && item.content.itemContent.topic.following) {
                    await fetch("https://twitter.com/i/api/graphql/srwjU6JM_ZKTj_QMfUGNcw/TopicUnfollow", {
                        headers: {
                            accept: "*/*",
                            "accept-language": "en-US,en;q=0.9",
                            authorization: authy,
                            "content-type": "application/json",
                            "sec-fetch-dest": "empty",
                            "sec-fetch-mode": "cors",
                            "sec-fetch-site": "same-origin",
                            "x-csrf-token": cooky,
                            "x-twitter-active-user": "yes",
                            "x-twitter-auth-type": "OAuth2Session",
                            "x-twitter-client-language": "en"
                        },
                        body: JSON.stringify({ variables: { topicId: item.content.itemContent.topic.topic_id }, queryId: "" }),
                        method: "POST",
                        mode: "cors",
                        credentials: "include"
                    });
                }
            }
        }
    } catch (error) {
        console.error('Error clearing topics and interests:', error);
    }
}

async function bookmarkPost(postId, onResponse) {
    try {
        const response = await fetch("https://api.twitter.com/graphql/aoDbu3RHznuiSkQ9aNM67Q/CreateBookmark", {
            headers: {
                "accept": "*/*",
                "authorization": authy,
                "content-type": "application/json",
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "x-csrf-token": cooky,
                "x-twitter-active-user": "yes",
                "x-twitter-auth-type": "OAuth2Session",
                "x-twitter-client-language": "en"
            },
            referrer: window.location.href,
            body: JSON.stringify({ variables: { tweet_id: postId }, queryId: "aoDbu3RHznuiSkQ9aNM67Q" }),
            method: "POST",
            mode: "cors",
            credentials: "include"
        });
        onResponse(response);
    } catch (err) {
        console.error('Error bookmarking post:', err);
    }
}

async function unbookmarkPost(postId, onResponse) {
    try {
        const response = await fetch("https://twitter.com/i/api/graphql/Wlmlj2-xzyS1GN3a6cj-mQ/DeleteBookmark", {
            headers: {
                "accept": "*/*",
                "authorization": authy,
                "content-type": "application/json",
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "x-csrf-token": cooky,
                "x-twitter-active-user": "yes",
                "x-twitter-auth-type": "OAuth2Session",
                "x-twitter-client-language": "en"
            },
            referrer: window.location.href,
            body: JSON.stringify({ variables: { tweet_id: postId }, queryId: "Wlmlj2-xzyS1GN3a6cj-mQ" }),
            method: "POST",
            mode: "cors",
            credentials: "include"
        });
        onResponse(response);
    } catch (err) {
        console.error('Error unbookmarking post:', err);
    }
}

//<--> GENERIC UTILITY FUNCTIONS <-->//
function watchForChange(root, obsArguments, onChange) {
    const rootObserver = new MutationObserver((mutations) => {
        rootObserver.disconnect();
        mutations.forEach((mutation) => onChange(root, mutation));
        rootObserver.observe(root, obsArguments);
    });
    rootObserver.observe(root, obsArguments);
    return rootObserver;
}

function watchForChangeFull(root, obsArguments, onChange) {
    const rootObserver = new MutationObserver((mutations) => {
        rootObserver.disconnect();
        onChange(root, mutations);
        rootObserver.observe(root, obsArguments);
    });
    rootObserver.observe(root, obsArguments);
    return rootObserver;
}

async function watchForAddedNodes(root, stopAfterFirstMutation, obsArguments, executeAfter) {
    const rootObserver = new MutationObserver((mutations) => {
        rootObserver.disconnect();
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length > 0) {
                executeAfter(mutation.addedNodes);
            }
        });
        if (!stopAfterFirstMutation) {
            rootObserver.observe(root, obsArguments);
        }
    });

    rootObserver.observe(root, obsArguments);
}

function findElem(rootElem, query, observer, resolve) {
    const elem = rootElem.querySelector(query);
    if (elem) {
        observer?.disconnect();
        resolve(elem);
    }
    return elem;
}

async function awaitElem(root, query, obsArguments) {
    return new Promise((resolve) => {
        if (findElem(root, query, null, resolve)) return;
        const rootObserver = new MutationObserver((mutations) => {
            findElem(root, query, rootObserver, resolve);
        });
        rootObserver.observe(root, obsArguments);
    });
}

function doOnAttributeChange(elem, onChange, repeatOnce = false) {
    const observerCallback = async (mutations, observer) => {
        observer.disconnect();
        await onChange(elem);
        if (!repeatOnce) {
            observer.observe(elem, { childList: false, subtree: false, attributes: true });
        }
    };

    const rootObserver = new MutationObserver(observerCallback);
    rootObserver.observe(elem, { childList: false, subtree: false, attributes: true });
}


function addHasAttribute(elem, attr) {
    if (elem.hasAttribute(attr)) {
        return true;
    }
    elem.setAttribute(attr, "");
    return false;
}


function getCookie(name) {
    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    return match ? match[2] : null;
}


function getCSSRuleContainingStyle(styleName, selectors, styleCnt = 0, matchingValue = "") {
    const sheets = document.styleSheets;

    for (const sheet of sheets) {
        if (!sheet.cssRules) continue;

        for (const rule of sheet.cssRules) {
            if (styleCnt && styleCnt !== rule.style.length) continue;

            if (rule.selectorText && rule.style.length > 0) {
                const selectorsArray = Array.isArray(selectors) ? selectors : [selectors];
                if (selectorsArray.some(selector => rule.selectorText.includes(selector)) &&
                    rule.style[styleName] === matchingValue) {
                    return rule;
                }
            }
        }
    }
    return null;
}


async function getUserPref(key, defaultVal)
{
    if (isGM) { return await GM.getValue(key, defaultVal); }
    return await GM_getValue(key, defaultVal);
}
async function setUserPref(key, value)
{
    if (isGM) { return await GM.setValue(key, value); }
    return await GM_setValue(key, value);
}

function LogMessage(text) {
    console.log(text);
}


function addGlobalStyle(css, id) {
    if (id && document.getElementById(id)) return;

    const head = document.head || document.getElementsByTagName('head')[0];
    if (!head) return;

    const style = document.createElement('style');
    style.type = 'text/css';
    if (id) style.id = id;
    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
    head.appendChild(style);
    return style;
}


function removeGlobalStyle(id) {
    const styleElem = document.getElementById(id);
    if (styleElem) {
        styleElem.parentNode.removeChild(styleElem);
    }
}



//<--> BEGIN PROCESSING <-->//

/*async function LoadPrefs()
{
    getUserPref(usePref_blurNSFW, false).then((res) => { toggleNSFW.enabled = res; });
}*/
// 2.0

function ObserveObj(observerConstraints, observeBehaviour, asyncGetElemBehaviour) {
    this.elem = null;
    this.observer = null;

    this.updateObserver = async function() {
        if (this.elem === null) {
            this.elem = await asyncGetElemBehaviour();

            observeBehaviour(this.elem, null);

            if (this.observer === null) {
                this.observer = watchForChangeFull(this.elem, observerConstraints, (elem, mutes) => {
                    observeBehaviour(elem, mutes);
                });
            } else {
                this.observer.observe(this.elem, observerConstraints);
            }
        }
    };

    this.updateObserver();
}


function HeaderData(header) {
    this.xLabel = '/ X';
    this.title = new ObserveObj(
        argsChildOnly,
        (title, mutes) => {
            if (title && title.innerText.endsWith(this.xLabel)) {
                title.innerText = title.innerText.replace(this.xLabel, '');
            }
        },
        async () => awaitElem(document.head, 'title', argsChildOnly)
    );

    this.meta = new ObserveObj(
        argsAll,
        (meta, mutes) => {
            if (meta && meta.content.endsWith(this.xLabel)) {
                meta.content = meta.content.replace(this.xLabel, '');
            }
        },
        async () => awaitElem(document.head, 'meta[content$="/ X"]', argsChildOnly)
    );

    this.shortcutIco = new ObserveObj(
        argsAttrOnly,
        (shortcutIco, mutes) => {
            if (shortcutIco) {
                shortcutIco.href = shortcutIco.href.replace('twitter.3', 'twitter.2');
            }
        },
        async () => awaitElem(document.head, 'link[rel="shortcut icon"]', argsChildOnly)
    );

    this.checkObservers = function() {
        this.title.updateObserver();
        this.meta.updateObserver();
        this.shortcutIco.updateObserver();
    };
}


var headerData = new HeaderData(document.head);
watchForChangeFull(document.head, argsChildOnly, () => headerData.checkObservers());

async function swapTwitterSplashLogo(reactRoot) {
    const placeholder = reactRoot.querySelector('div#placeholder svg');
    if (placeholder) {
        placeholder.innerHTML = twitSVG;
    }

    const logo = await awaitElem(reactRoot, 'header h1 > a svg', argsChildAndSub);
    logo.innerHTML = twitSVG;
}


function replaceWithVX(txt) {
    if (!toggleMakeLinksVX.enabled) { return txt; }
    if (txt.includes('/status/') && !txt.includes('//fixupx.com/')) {
        if (!txt.includes('.com')) {
            return 'https://fixupx.com' + txt;
        }
        return txt.split('?')[0]
                   .replace('//twitter.com/', '//fixupx.com/')
                   .replace('//x.com/', '//fixupx.com/');
    }
    return txt;
}


document.addEventListener('copy', function(e) {
    if (toggleMakeLinksVX.enabled) {
        const txt = e?.srcElement?.innerText;
        if (txt && (txt.startsWith('http') || txt.startsWith("x.com") || txt.startsWith("twitter.com"))) {
            const updatedTxt = replaceWithVX(txt);
            e.clipboardData.setData('text/plain', updatedTxt);
            e.preventDefault();
        }
    }
});


(async function () {
    'use strict';

    if (isDirectImagePage(window.location.href)) { return; }

    let prefsLoading = loadToggleValues();

    await awaitElem(document, 'BODY', argsChildAndSub);
    NodeList.prototype.forEach = Array.prototype.forEach;
    preCursor = document.body.style.cursor;
    initializeCtxMenu();

    const isIframe = document.body.querySelector('div#app');

    if (isIframe) {
        await awaitElem(isIframe, 'article[role="article"]', argsChildAndSub).then(listenForMediaType);
        return;
    }

    const reactRoot = await awaitElem(document.body, 'div#react-root', argsChildAndSub);
    await swapTwitterSplashLogo(reactRoot);
    const main = await awaitElem(reactRoot, 'main[role="main"] div', argsChildAndSub);
    await prefsLoading;

    const layers = reactRoot.querySelector('div#layers');

    await awaitElem(reactRoot, 'div#layers', argsChildAndSub).then((layers) => {
        if (!addHasAttribute(layers, "watchingLayers")) {
            watchForChange(layers, { childList: true, subtree: true }, onLayersChange);
        }
    });

    addHasAttribute(main, modifiedAttr);

    onMainChange(main);
    watchForChange(main, argsChildOnly, onMainChange);
})();
